trigger:
  branches:
    include:
      - dev

pr: none

parameters:
  - name: resourceType
    default: 'Microsoft.Web/sites'

variables:
  envName: 'dev'   
  functionAppName: 'AzdoTools'
  notes: 'Deploying to the development environment'
  healthCheckUrl: 'https://azdotools-dev.azurewebsites.net/api/health'
  metadataArtifactName: 'ProvisionMetadata_Final'
  provisionArtifactName: 'ProvisionMetadata_Final'
  scriptPath: '$(Build.SourcesDirectory)/pipelines/scripts'
  pipelineName: 'infraProducer'
  manifestPath: '$(Pipeline.Workspace)/infraProducer/ProvisionMetadata_Final/manifest.json'
  provisionResultPath: '$(Pipeline.Workspace)/infraProducer/ProvisionMetadata_Final/provision-results.json'
  artifactName: 'AzdoTools-dev'

resources:
  pipelines:
    - pipeline: infraProducer
      source: azdo-tools-infrastructure
      trigger: none

stages:
- stage: DownloadInfraArtifacts
  displayName: 'Download Infra Artifacts'
  jobs:
    - job: FetchInfra
      displayName: 'Fetch ProvisionMetadata_Final'
      pool:
        vmImage: 'ubuntu-latest'
      steps:
        - download: infraProducer
          artifact: ProvisionMetadata_Final

        - script: |
            echo "🔍 Listing all downloaded artifacts:"
            ls -la $(Pipeline.Workspace)
          displayName: 'Debug: List Pipeline Workspace'

- stage: ValidateInfra
  displayName: 'Validate Dev Environment Provisioning'
  dependsOn: DownloadInfraArtifacts
  jobs:
    - job: ValidateDevInfra
      pool:
        vmImage: 'ubuntu-latest'
      steps:
        - task: PowerShell@2
          displayName: 'Read Artifact Metadata'
          inputs:
            targetType: 'filePath'
            filePath: '${{ variables.scriptPath }}/Read-ArtifactMetadata.ps1'
            arguments: >
              -MetadataPath "${{ variables.manifestPath }}"

        - script: |
            if [ ! -f "${{ variables.provisionResultPath }}" ]; then
              echo "##vso[task.logissue type=error]Provision result file not found at expected path: ${{ variables.provisionResultPath }}"
              exit 1
            fi
          displayName: 'Validate Provision Result File Exists'
          failOnStderr: true

        - task: PowerShell@2
          displayName: 'Validate Provisioning Result'
          inputs:
            targetType: 'filePath'
            filePath: '${{ variables.scriptPath }}/Validate-ProvisionResult.ps1'
            arguments: >
              -ResultFilePath "${{ variables.provisionResultPath }}"
              -EnvName "${{ variables.envName }}"

- stage: BuildAndTest
  displayName: 'Build and Run Unit Tests'
  dependsOn: ValidateInfra
  condition: succeeded()
  jobs:
  - job: BuildAndTest
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self

    - task: DotNetCoreCLI@2
      displayName: 'Build Solution'
      inputs:
        command: 'build'
        projects: '**/*.csproj'

    - task: DotNetCoreCLI@2
      displayName: 'Run Unit Tests'
      inputs:
        command: 'test'
        projects: '**/*UnitTests.csproj'
        arguments: '--configuration Release --no-build'

- stage: Deploy
  displayName: 'Deploy to Dev Environment'
  dependsOn: BuildAndTest
  condition: succeeded()
  jobs:
  - job: ReadManifest
    displayName: 'Read or Generate Manifest'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - template: ../templates/manifest-read.yml
      parameters:
        manifestPath: ${{ variables.manifestPath }}
        artifactName: ${{ variables.artifactName }}
        version: 'dev-$(Build.BuildId)'
        notes: ${{ variables.notes }}

  - job: DeployFunctionApp
    dependsOn: ReadManifest
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self
  
    - task: PowerShell@2
      displayName: 'Extract Deployment Metadata from Manifest'
      inputs:
        targetType: 'inline'
        script: |
          $manifestPath = "${{ variables.manifestPath }}"
          if (!(Test-Path $manifestPath)) {
            Write-Host "❌ Manifest not found at $manifestPath"
            exit 1
          }
  
          $manifest = Get-Content $manifestPath | ConvertFrom-Json
          $resourceGroup = $manifest.ResourceGroupName
          $functionAppName = $manifest.FunctionAppName
  
          Write-Host "✅ Extracted Resource Group: $resourceGroup"
          Write-Host "✅ Extracted Function App Name: $functionAppName"
  
          # Set pipeline variables
          Write-Host "##vso[task.setvariable variable=ResourceGroupName]$resourceGroup"
          Write-Host "##vso[task.setvariable variable=FunctionAppName]$functionAppName"

    - task: AzureCLI@2
      displayName: 'Deploy Function App via Zip Deploy'
      inputs:
        azureSubscription: 'HolyCheese-ServiceConnection'
        scriptType: ps
        scriptLocation: inlineScript
        inlineScript: |
          $artifactPath = "$(Pipeline.Workspace)/${{ variables.artifactName }}/functionapp.zip"
          $resourceGroup = "$(ResourceGroupName)"
          $functionAppName = "$(FunctionAppName)"
          $version = "$(Build.BuildNumber)"
   
          if (!(Test-Path $artifactPath)) {
            Write-Host "❌ Artifact not found at $artifactPath"
            exit 1
          }
   
          Write-Host "📦 Deploying $functionAppName to $resourceGroup using ZIP package: $artifactPath"
          az functionapp deployment source config-zip `
            --resource-group $resourceGroup `
            --name $functionAppName `
            --src $artifactPath
   
          Write-Host "✅ Deployment completed for version: $version"

    - template: ../templates/manifest-write.yml
      parameters:
        manifestPath: ${{ variables.manifestPath }}
        artifactPath: $(Pipeline.Workspace)/${{ variables.artifactName }}/functionapp.zip
        version: $(Build.BuildNumber)
        notes: ${{ variables.notes }}
        branch: $(Build.SourceBranchName)
        commit: $(Build.SourceVersion)
        environment: ${{ variables.envName }}

  - job: HealthCheck
    dependsOn: DeployFunctionApp
    condition: succeeded()
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: PowerShell@2
      displayName: 'Health Check'
      inputs:
        targetType: 'filePath'
        filePath: '${{ variables.scriptPath }}/HealthCheck.ps1'
        arguments: >
          -Url $(healthCheckUrl)
